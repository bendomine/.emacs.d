#+title: Emacs Configuration
#+author: Ben Domine
#+property: header-args:emacs-lisp :tangle yes :results silent
#+startup: overview

* Early Initialization
** Config File Shortcut
Because of how frequently I visit this file, I want a function to quickly find it. I want this to be the very first thing I do, so that if something breaks this function still ends up loading whenever possible.
#+begin_src emacs-lisp
  (defun config ()
      "Find the config file."
      (interactive)
      (find-file "~/.emacs.d/config.org"))
#+end_src

** Other Config Files
Store customize code in a different file:
#+begin_src emacs-lisp
  (setq custom-file "~/.emacs.d/custom.el")
  (load custom-file 'noerror)
#+end_src

Packages Iâ€™m currently developing will be in different files; load them also:
#+begin_src emacs-lisp
  (load "~/.emacs.d/my-project-manager.el")
#+end_src
** Basic GUI Tweaks
First GUI customizations. We want fullscreen, no tool bar, and a dark frame:
#+begin_src emacs-lisp
  (tool-bar-mode -1)
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
  (set-frame-parameter nil 'ns-appearance 'dark)
#+end_src

** Package Management
Weâ€™ll be using use-package. Much of this code comes from [[https://www.shaneikennedy.xyz/blog/emacs-intro][this blog post]] by Shane Kennedy.
First, a macro for appending to a list:
#+begin_src emacs-lisp
  (defmacro append-to-list (target suffix)
      "Append SUFFIX to TARGET in place."
      `(setq ,target (append ,target ,suffix)))
#+end_src

Next, weâ€™ll update our package archives:
#+begin_src emacs-lisp
  (require 'package)

  (append-to-list package-archives
      '(("melpa" . "http://melpa.org/packages/")
           ("melpa-stable" . "http://stable.melpa.org/packages/")
           ("org-elpa" . "https://orgmode.org/elpa/")))
#+end_src

And load from our package list:
#+begin_src emacs-lisp
  (package-initialize)
#+end_src

Now weâ€™ll set up use-package. We need to refresh the package archive so we can get the latest packages, and install use-package.
#+begin_src emacs-lisp
  (unless (package-installed-p 'use-package)
      (package-refresh-contents)
      (package-install 'use-package))
#+end_src

Finally, some settings for use-pacakge. We want to make ensure the default, which causes use-package to download stuff if itâ€™s not installed. We also want to turn on verbose installation, so that we get error logging when something breaks.
#+begin_src emacs-lisp
  (setq
      use-package-always-ensure t
      use-package-verbose t)
#+end_src
* Keybindings
** Mac Rebinding
I primarily use Mac, so I want most keybindings to use the command key. So, Iâ€™ll switch the command and control keys.
#+begin_src emacs-lisp
  (setq mac-command-modifier 'control)
  (setq mac-control-modifier 'super)
#+end_src

This means that I need to resolve the keyboard conflicts that arise from mac taking over certain commands, such as command + space.
#+begin_src emacs-lisp
  (if (eq system-type 'darwin)
      (global-set-key (kbd "C-j") 'set-mark-command))
#+end_src

* UI
** Scrolling
I want precision pixel scrolling, meaning that when I use the scroll wheel I want smooth scrolling instead of line-by-line scrolling. This obviously only has an impact in GUI mode. Also, it can cause lag depending on the machine and version/port of emacs!
#+begin_src emacs-lisp
  (pixel-scroll-precision-mode)
#+end_src

** Icons
Iâ€™m using nerd-icons for doom-modeline and other icon-requiring packages.
#+begin_src emacs-lisp
  (use-package nerd-icons
      :custom
      (nerd-icons-font-family "Symbols Nerd Font Mono")
      )
#+end_src

Note: if this doesnâ€™t work on a new computer, run nerd-icons-install-fonts.
** Themes
Iâ€™ll use doom-themes because of its broad selection. Screenshots of some of these themes can be found [[https://github.com/doomemacs/themes/tree/screenshots][here]].

This is a short list of themes I like:
:themes:
- Doom-one (boring but classic)
- doom-city-lights
- Doom-oceanic-next
- doom-dark+
- Doom-solarized-dark (maybe)
- Doom-outrun-electric (probably not, it looks cool as hell though)
- Doom-snazzy (pretty basic but nice contrast)
- Doom-dracula (I really like this one actually)
:END:
For now Iâ€™ll just go with dark+.
#+begin_src emacs-lisp :results silent
  (use-package doom-themes
      :init
      (load-theme 'doom-dark+))
#+end_src

I want the active line number in line number mode to be highlighted more brightly:
#+begin_src emacs-lisp
  (set-face-attribute 'line-number-current-line nil
      :foreground (face-attribute 'highlight :background))
#+end_src

** Modeline
So far, my modeline is just a mostly uncustomized doom-modeline. The documentation options can be found at [[https://github.com/seagle0128/doom-modeline][the github repo]].
#+begin_src emacs-lisp
  (use-package doom-modeline
      :ensure t
      :init (doom-modeline-mode 1))
#+end_src

Iâ€™ve had some issues with lag in the past, and I heard that this was supposed to help:
#+begin_src emacs-lisp
  (setq inhibit-compacting-font-caches t)
#+end_src

Letâ€™s take advantage of the icons weâ€™ve added and force doom-modeline to use them. This should be on by default but it canâ€™t hurt.
#+begin_src emacs-lisp
  (setq doom-modeline-icon t)
#+end_src

I also want to see the time, but not the system load average:
#+begin_src emacs-lisp
  (setq display-time-default-load-average nil)
  (setq doom-modeline-time-icon t)
  (setq doom-modeline-time t)
  (display-time)
#+end_src

Just for fun, Iâ€™ll also enable the battery indicator, updating every 30 seconds:
#+begin_src emacs-lisp
  (setq battery-update-interval 30)
  (setq doom-modeline-battery t)
  (display-battery-mode +1)
#+end_src

** Tabs
I currently use centaur-tabs, though Iâ€™m not sure how much I like it.
#+begin_src emacs-lisp
  (use-package centaur-tabs
      :demand
      :config
      (set-face-attribute 'centaur-tabs-default nil :height 5)
      (centaur-tabs-mode t)
      )
#+end_src

I want to display the icon for the current buffer in each tab:
#+begin_src emacs-lisp
  (setq centaur-tabs-set-icons t)
  (setq centaur-tabs-icon-type 'nerd-icons)
#+end_src

And a few other graphical things. I want a marker for unsaved changes, no new tab button, bar-style tabs, and a highlight bar to the left. Finally, weâ€™ll set the height to 5.
#+begin_src emacs-lisp
  (setq centaur-tabs-style "bar")
  (setq centaur-tabs-set-modified-marker t)
  (setq centaur-tabs-set-bar 'left)
  (set-face-attribute 'centaur-tabs-default nil :height 5)
#+end_src

Next, I need a tab grouping function. I only want tabs for buffers that are part of a project, and then I want the tabs to be grouped by that project. Iâ€™ll group by the projectile project:
#+begin_src emacs-lisp
  (centaur-tabs-group-by-projectile-project)
#+end_src

At some point, Iâ€™ll add functionality to hide the tab bar when in a buffer that isnâ€™t part of a project. For now, Iâ€™ll be content with hiding tabs in special mode buffers:
#+begin_src emacs-lisp
  (add-hook 'special-mode-hook 'centaur-tabs-local-mode)
#+end_src

** Minibuffer
Using vertico-posframe, itâ€™s possible to have the minibuffer in the center of the screen. Iâ€™m not sure how much Iâ€™ll like this functionality, but Iâ€™ll test it out for now.
#+begin_src emacs-lisp
  (use-package vertico-posframe
      :after vertico
      :config
      (setq vertico-posframe-handler
          'posframe-poshandler-frame-center)
      (vertico-posframe-mode 1))
#+end_src

* Core Editing
** Project Management
I originally used project.el, but Iâ€™ve decided to try projectile instead. Iâ€™ll add that now:
#+begin_src emacs-lisp
  (use-package projectile
      :ensure t
      :init
      (setq projectile-project-search-path '("~/Coding"))
      :config
      (projectile-mode +1)
      :bind (:map projectile-mode-map
                ("C-c C-p" . projectile-command-map)))
#+end_src
** Jumping
I use Avy to quickly jump to any visible text. The function I primarily use here is goto-char-timer, and Iâ€™ve dropped that timer all the way down to 0.15 seconds for speed.
+I previously used goto-char-timer, and Iâ€™m starting to realize that itâ€™s not the best for me. I always end up typing the whole word, or if not, thinking about how many characters to type. This is suboptimal, so I need a consistent method. Given this, I should just use goto-char or goto-char-2. Iâ€™ll start by trying goto-char-2.+
#+begin_src emacs-lisp
  (use-package avy
      :ensure t
      :config
      (setq avy-timeout-seconds 0.15)
      :bind (("M-j" . avy-goto-char-timer)))

#+end_src

Just for visual clarity, I also want to briefly highlight the thing we jump to. In order to do this, letâ€™s define a function for briefly pulsing the current thing:
#+begin_src emacs-lisp
  (defun pulse-symbol-at-point ()
      "Briefly pulse the symbol under the current point."
      (interactive)
      (let* ((bounds (bounds-of-thing-at-point 'symbol))
                (first (car bounds))
                (last (cdr bounds)))
          (pulse-momentary-highlight-region first last)))
#+end_src

+Next, run this function whenever we jump from Avy:+ The new goto-char-2 function breaks this, so Iâ€™ll have to fix it later if I decide to stay with goto-char-2.
#+begin_src emacs-lisp
  (require 'avy)

  (advice-add 'avy-goto-char-timer :after #'pulse-symbol-at-point)
#+end_src

I also want this functionality on each jump of an incremental search.
#+begin_src emacs-lisp
  (add-hook 'isearch-mode-end-hook #'pulse-symbol-at-point)
#+end_src

** Multiple Cursors
This oneâ€™s pretty straightforward. As a former VSCode user, I like multiple cursors for simultaneously editing different things (and it just looks really cool).
#+begin_src emacs-lisp
  (package-install 'multiple-cursors)
  (require 'multiple-cursors)
#+end_src

Note: a list of mc commands can be found [[https://github.com/magnars/multiple-cursors.el?tab=readme-ov-file#command-overview][here]].

Iâ€™m not using anything close to the full functionality of this package; for now, I just want to bind C-d and C-S-d to mark and unmark the next instances of the current word.
#+begin_src emacs-lisp
  (global-set-key (kbd "C-d") 'mc/mark-next-like-this-word)
  (global-set-key (kbd "C-S-d") 'mc/unmark-next-like-this)
#+end_src

When using this command, the word is selected by default. This leads to some inconvenience, so Iâ€™ll disable delete-selection-mode so that itâ€™s possible to type stuff at the end of a word after using this command. We then re-enable it after exiting mc mode. I also make sure delete-selection-mode is enabled to begin with.
#+begin_src emacs-lisp
  (delete-selection-mode 1)
  (add-hook 'multiple-cursors-mode-hook (lambda () (delete-selection-mode -1)))
  (add-hook 'multiple-cursors-mode-disabled-hook (lambda () (delete-selection-mode 1)))
#+end_src

By default, return is bound to disable mc mode. I dislike this.
#+begin_src emacs-lisp
  (define-key mc/keymap (kbd "<return") nil)
#+end_src

Finally, the c++ mode keymap eats C-d. It would be better practice to bind it to something like C-c d, but Iâ€™m more used to C-d, so Iâ€™ll try to rebind that. Note: this doesnâ€™t actually work ðŸ˜¥.
#+begin_src emacs-lisp
  (with-eval-after-load 'c++-mode
      (define-key c++-mode-map (kbd "C-d") nil))
#+end_src
** Moving Lines
This is a feature from VSCode that I quite like. The idea is to move lines around with M-up and M-down, and also to duplicate lines up and down with M-S-up and M-S-down.

Letâ€™s start with swapping lines up and down:
#+begin_src emacs-lisp
  (defun swap-line-up ()
      "Swap the current line with the one above it, retaining cursor position."
      (interactive)
      (if (/= (line-number-at-pos) 1)
          (let ((col (current-column)) (line (line-number-at-pos)))
              (transpose-lines 1)
              (goto-line (- line 1))
              (move-to-column col)
              )))
  
  (defun swap-line-down ()
      "Swap the current line with the one below it, retaining cursor position."
      (interactive)
      (if (/= (line-number-at-pos) (count-lines (point-min) (point-max)))
          (let ((col (current-column)) (line (line-number-at-pos)))
              (forward-line 1)
              (transpose-lines 1)
              (goto-line (+ line 1))
              (move-to-column col)
              )))
#+end_src

We then bind these to keys:
#+begin_src emacs-lisp
    (global-set-key (kbd "M-<up>") 'swap-line-up)
    (global-set-key (kbd "M-<down>") 'swap-line-down)
#+end_src

Duplicating up is very straightforward:
#+begin_src emacs-lisp
  (global-set-key (kbd "M-S-<up>") 'duplicate-line)  
#+end_src

Finally, duplicating down:
#+begin_src emacs-lisp
  (global-set-key (kbd "M-S-<down>") (lambda ()
                                         (interactive)
                                         (let ((col (current-column)))
                                             (duplicate-line)
                                             (forward-line 1)
                                             (move-to-column col))))
#+end_src
** Visual Line Mode
I want visual line mode enabled in text modes:
#+begin_src emacs-lisp
  (add-hook 'text-mode-hook 'visual-line-mode)
#+end_src
** Snippets
For snippets, particularly in LaTeX and HTML, Iâ€™ll use yasnippet:
#+begin_src emacs-lisp
  (use-package yasnippet
  	:hook (prog-mode . yas-minor-mode)
  	:config
  	(yas-reload-all))
  (yas-global-mode)
#+end_src

* Completions and Search
** Keybinding Completion
Iâ€™ll use the which-key package to help with completions for keybindings.
#+begin_src emacs-lisp
  (use-package which-key
      :ensure t
      :config
      (which-key-mode +1))
#+end_src
** Minibuffer Completion
For completion in the minibuffer, Iâ€™ll use vertico:
#+begin_src emacs-lisp
  (use-package vertico
      :init
      (vertico-mode))
#+end_src

I also want to hide all commands that arenâ€™t available in the current mode. This snippet comes from the Shane Kennedy blog post I linked previously.
#+begin_src emacs-lisp
  (use-package emacs
      :custom
      (read-extended-command-predicate #'command-completion-default-include-p))
#+end_src

Finally, Iâ€™ll use marginalia. This package makes it so that the completion options in the minibuffer also display the docstring for that command.
#+begin_src emacs-lisp
  (use-package marginalia
      :init
      (marginalia-mode))
#+end_src
** In-Buffer Completion
As far as I can tell, there are two primary options for in-buffer completion: company and corfu. Because Iâ€™m already using other Minad packages, it seems most logical to go for corfu here. This is a pretty minimal setup. I currently have a map thatâ€™s commented out, because Iâ€™m still deciding on the best keybindings here.
#+begin_src emacs-lisp
  (use-package corfu
      :custom
      (corfu-auto t)
      (corfu-cycle t) ;; Enable cycling for `corfu-next/previous'
      :bind
      (:map corfu-map
          ;;     ("TAB" . corfu-next)
          ;;     ("C-n" . corfu-next)
          ;;     ([tab] . corfu-next)
          ;;     ("C-p" . corfu-previous)
          ;;     ("S-TAB" . corfu-previous)
          ;;     ([backtab] . corfu-previous)
  		("M-<backspace>" . backward-kill-word)
  		("C-<backspace>" . backward-kill-word)
          ("ESC" . corfu-quit)))
#+end_src

I want completion in programming buffers:
#+begin_src emacs-lisp
  (global-corfu-mode)
#+end_src

I also want to delay the completion a little bit, instead of it popping up immediately. I have this code set up to add a time delay of 0.2 seconds; however, the corfu documentation states that this can create lag, so Iâ€™ve commented it out for now.
#+begin_src emacs-lisp
;;  (setq corfu-auto-delay 0.2)
#+end_src
** Fuzzy Matching
I use orderless to give completions fuzzy matching. This particular bit of code is copied directly from the Shane Kennedy blog post.
#+begin_src emacs-lisp
  (use-package orderless
      :custom
      (completion-styles '(orderless basic))
      (completion-category-defaults nil)
      (completion-category-overrides '((file (styles partial-completion)))))
#+end_src
** Searching
Iâ€™ll use Consult for better searching. When I say "use" I donâ€™t actually mean use, because I havenâ€™t figured it out yet. However, Iâ€™ll install it for now.
#+begin_src emacs-lisp
(use-package consult
        :hook (completion-list-mode . consult-preview-at-point-mode)
        :custom
        (consult-preview-key nil)
        (consult-narrow-key nil)
        :config
        (consult-customize consult-theme consult-line consult-line-at-point :preview-key '(:debounce 0.2 any))
        )
#+end_src

* Org Mode
** UI Improvements
Iâ€™m using org-modern to improve the ui on org-mode documents. I havenâ€™t customized this much yet, but probably will do so in the future.
#+begin_src emacs-lisp
  (package-install 'org-modern)
  (with-eval-after-load 'org (global-org-modern-mode))
#+end_src

I also want my documents centered when on a larger screen, so Iâ€™ll use Olivetti.
#+begin_src emacs-lisp
  (package-install 'olivetti)
  (setq olivetti-body-width 0.6)
  (add-hook 'org-mode-hook #'olivetti-mode)
#+end_src

Finally, I always want org indent mode on. This indents subsequent headings and just makes it much easier to see what heading Iâ€™m under. Iâ€™ll also enable visual line mode.
#+begin_src emacs-lisp
  (add-hook 'org-mode-hook 'org-indent-mode)
  (add-hook 'org-mode-hook 'visual-line-mode)
#+end_src
** LaTeX
I use CDLatex to input LaTeX quickly.
#+begin_src emacs-lisp
  (package-install 'cdlatex)
  (require 'cdlatex)
#+end_src

I also have a few custom templates for CDLatex.
#+begin_src emacs-lisp
  (setq cdlatex-command-alist
      '(("lap" "Insert Laplace transform" "\\mathcal L {" cdlatex-lr-pair nil nil t)
           ("ilap" "Insert inverse Laplace transform" "\\mathcal L^{-1} {" cdlatex-lr-pair nil nil t)
           ("lim" "Insert limit" "\\lim_{?}" cdlatex-position-cursor nil nil t)
           ("()" "Insert inline math" "\\(?\\)" cdlatex-position-cursor nil t nil)
           ("hb" "Insert \\hbar" "\\hbar" nil nil nil t)))
#+end_src

Finally, though this is not directly related to org mode, I have a custom command to insert inline math, bound to C-(. It uses CDLatex to move the cursor back to the center of the parentheses.
#+begin_src emacs-lisp
  (defun begin-inline-math ()
      "Begins an inline math environment with \\(\\).  Requires cdlatex."
      (interactive)
      (insert "\\(?\\)")
      (cdlatex-position-cursor))
  (add-hook 'org-cdlatex-mode-hook (lambda ()
                                       (keymap-set org-cdlatex-mode-map "C-(" #'begin-inline-math)))  
#+end_src

Now we need to ensure that CDLatex is enabled in all org mode buffers.
#+begin_src emacs-lisp
  (add-hook 'org-mode-hook #'turn-on-org-cdlatex)
#+end_src

Iâ€™ll also use Auctex for some other LaTeX utilities like syntax highlighting.
#+begin_src emacs-lisp
  (package-install 'auctex)
  (setq TeX-auto-save t)
  (setq TeX-parse-self t)
  (setq-default TeX-master nil)
#+end_src
** Encryption
Iâ€™ll use GPG and org-crypt to allow for the encryption of specific headings in org mode.
#+begin_src emacs-lisp
  (require 'org-crypt)
  (org-crypt-use-before-save-magic)
  (setq org-crypt-key nil)
#+end_src

I want encryption on the crypt tag:
#+begin_src emacs-lisp
  (setq org-crypt-tag-matcher "crypt")
  (setq org-tags-exclude-from-inheritance '("crypt"))
#+end_src

** Roam
Previous note-taking has been accomplished with text files, and more recently with hierarchical org note files. Iâ€™d like to instead use org-roam for notes.
#+begin_src emacs-lisp
  (use-package org-roam
  	:ensure t
  	:custom
  	(org-roam-directory "~/org-roam")
  	:bind (("C-c n l" . org-roam-buffer-toggle)
  			  ("C-c n f" . org-roam-node-find)
  			  ("C-c n i" . org-roam-node-insert)
  			  :map org-roam-dailies-map
  			  ("Y" . org-roam-dailies-capture-yesterday)
  			  ("T" . org-roam-dailies-capture-tomorrow))
  	:bind-keymap
  	("C-c n d" . org-roam-dailies-map)
  	:config
  	(require 'org-roam-dailies)
  	(org-roam-setup))
#+end_src

The org-roam author recommends displaying the org-roam buffer as a separate window like this:
#+begin_src emacs-lisp
  (add-to-list 'display-buffer-alist
  	'("\\*org-roam\\*"
  		 (display-buffer-in-direction)
  		 (direction . right)
  		 (window-width . 0.33)
  		 (window-height . fit-window-to-buffer)))
#+end_src

Iâ€™ll want to create some custom capture templates at some point, so Iâ€™ll override the templates variable, currently only providing the default template:
#+begin_src emacs-lisp
  (setq org-roam-capture-templates
    	'(("d" "default" plain "%?"
    		  :target (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
    					  "#+title: ${title}\n")
    		  :unnarrowed t
  		  :empty-lines 1
  		  )))
#+end_src
** Roam Dailies
All daily roam notes should be stored in the /daily subfolder:
#+begin_src emacs-lisp
  (setq org-roam-dailies-directory "daily/")
#+end_src

I want two capture templates. The first is copied directly from the documentation, and consists solely of a single headline. The second is for journal entries, and is therefore its own node.
#+begin_src emacs-lisp
  (setq org-roam-dailies-capture-templates
      '(("d" "default" plain
            "* %?"
            :target (file+head "%<%Y-%m-%d>.org"
                        "#+title: %<%Y-%m-%d>\n")
  		  :empty-lines 1)
  		 ("j" "journal" entry
  			 "* Journal: %^{Title}\n\n%?"
  			 :target (file+head "%<%Y-%m-%d>.org"
  						 "#+title: %<%Y-%m-%d>\n")
  			 :empty-lines 1)
  		 ))
#+end_src
** Roam UI
Thereâ€™s a package for displaying a graph of all your org-roam nodes. I donâ€™t think itâ€™s that useful, but it looks cool so why not.
#+begin_src emacs-lisp
  (use-package org-roam-ui
      :after org-roam
  	;;         normally we'd recommend hooking orui after org-roam, but since org-roam does not have
  	;;         a hookable mode anymore, you're advised to pick something yourself
  	;;         if you don't care about startup time, use
  	;;  :hook (after-init . org-roam-ui-mode)
      :config
      (setq org-roam-ui-sync-theme t
          org-roam-ui-follow t
          org-roam-ui-update-on-save t
          org-roam-ui-open-on-start t))
#+end_src

In the future, Iâ€™d like to prevent it from automatically opening a tab in my browser, and instead display it with an xwidget-webkit.

** Custom Commands
One great thing about org mode is that you can have a large document but hide the majority of it, excepting only what youâ€™re currently working on. However, thereâ€™s no good command to do this. Iâ€™m therefore adding a shortcut by combining two other commands.
#+begin_src emacs-lisp
  (defun org-fold-all-reveal ()
  	"Cycle global visibility, then reveal."
  	(interactive)
  	(org-shifttab 1)
  	(org-fold-reveal)
  	)
#+end_src

I want this bound to C-c C-h in org mode.
#+begin_src emacs-lisp
  (define-key org-mode-map (kbd "C-c C-h") #'org-fold-all-reveal)
#+end_src

* Programming
** Language Server Protocol Client
I previously used the built-in Eglot for language server protocol support, but itâ€™s been too slow for my purposes. Iâ€™m therefore switching to the lsp-mode package. Documentation for this package can be found [[https://emacs-lsp.github.io/lsp-mode/][here]].
#+begin_src emacs-lisp
  (use-package lsp-mode
  	:init
  	(setq lsp-keymap-prefix "C-c l")
  	:hook (
  			  (python-mode . lsp)
  			  (javascript-mode . lsp)
  			  (lsp-mode . lsp-enable-which-key-integration))
  	:commands lsp
  	:custom
  	(lsp-enable-snippet t)
  	(lsp-completion-provider :none))
#+end_src

I also want the ui integrations of lsp-mode, which adds nice features like sideline, peek, and documentation.
#+begin_src emacs-lisp
  (use-package lsp-ui :commands lsp-ui-mode)
#+end_src

The website also recommends adding the lsp-mode folders to the load path:
#+begin_src emacs-lisp
  (add-to-list 'load-path (expand-file-name "lib/lsp-mode" user-emacs-directory))
  (add-to-list 'load-path (expand-file-name "lib/lsp-mode/clients" user-emacs-directory))
#+end_src

I want to use Treemacs with lsp-mode:
#+begin_src emacs-lisp
  (use-package lsp-treemacs :commands lsp-treemacs-errors-list)
  (require 'lsp-treemacs)
  (lsp-treemacs-sync-mode 1)
#+end_src

** Language Servers
For c++, I want to use clangd. Iâ€™m going to assume this is already installed via homebrew on mac:
#+begin_src emacs-lisp
  ;; (if (eq system-type 'darwin)
  ;; 	(setq lsp-clients-clangd-executable "/opt/homebrew/bin/clangd"))
#+end_src

** Web Development
For quick completions, Iâ€™ll use emmet-mode:
#+begin_src emacs-lisp
  (use-package emmet-mode
  	:hook (html-mode css-mode web-mode))
#+end_src

** Syntax Highlighting
Iâ€™ll use tree-sitter for syntax highlighting. Tree-sitter is included with Emacs, but in order to use it in every compatible buffer Iâ€™ll use treesit-auto:
#+begin_src emacs-lisp
  (use-package treesit-auto
    :custom
    (treesit-auto-install 'prompt)
    :config
    (treesit-auto-add-to-auto-mode-alist 'all)
    (global-treesit-auto-mode))
#+end_src
** Linting
Iâ€™ll use flycheck for syntax linting.
#+begin_src emacs-lisp
  (use-package flycheck
        :config
        (add-hook 'prog-mode-hook 'flycheck-mode)
        (add-hook 'after-init-hook #'global-flycheck-mode))
#+end_src

One issue Iâ€™ve found is flycheck using old c++ language standards. This is an attempt to set them to 2011:
#+begin_src emacs-lisp
  (add-hook 'c++-mode-hook (lambda () (setq flycheck-gcc-language-standard "c++11" flycheck-clang-language-standard "c++11")))
  (add-hook 'c++-mode-hook (lambda () (setq flycheck-gcc-language-standard "c++11")))
  (add-hook 'c++-mode-hook (lambda () (setq flycheck-clang-language-standard "c++11")))
#+end_src
Unfortunately, I donâ€™t think itâ€™s a successful attempt.

** Version Control
For help with version control, Iâ€™ll use magit. I currently donâ€™t have this customized at all.
#+begin_src emacs-lisp
  (use-package magit)
#+end_src

** Indentation
Iâ€™m a proud tabs user. We want to use tabs whenever possible:
#+begin_src emacs-lisp
  (setq-default indent-tabs-mode t)

  ;; idk if itâ€™s necessary, but just to be extra sure:
  (add-hook 'prog-mode-hook (lambda () (setq indent-tabs-mode t)))
#+end_src

I want a tab size of 4:
#+begin_src emacs-lisp
  (setq-default tab-width 4)
  (setq-default standard-indent 4)
#+end_src

And I want to use tabs for every mode:
#+begin_src emacs-lisp
  (setq js-indent-level 4
      typescript-indent-level 4
  	python-indent-offset 4
  	c-basic-offset 4
  	lisp-indent-offset 4)
#+end_src

** Line numbers
I want line numbers when programming. The last two lines here make sure the line number bar takes up a constant amount of space, preventing weird shifts when scrolling.
#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
  (setq display-line-numbers-width-start t)
  (setq display-line-numbers-grow-only t)

#+end_src

** Electric Pair Mode
I want electric pair mode enabled whenever Iâ€™m programming, but only then:
#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook 'electric-pair-local-mode)
#+end_src

* Projects
** Web Server
I often want to start a server to preview a web project. Iâ€™ll use a custom function to do this, using projectile. Iâ€™ve bound this to C-c C-p w, which is the projectile prefix + w.
#+begin_src emacs-lisp
  (require 'projectile)
  (defun start-web-server-in-project ()
      "Start a simple Python web server in root directory of current project."
      (interactive)
      (projectile-run-async-shell-command-in-root "python3 -m http.server"))

  (define-key projectile-mode-map (kbd "C-c C-p w") #'start-web-server-in-project)
#+end_src
** Treemacs
Treemacs is a package which creates a buffer displaying the file structure of the current project.
#+begin_src emacs-lisp
  (use-package treemacs
      :ensure t
      :defer t
      :bind
  	(:map global-map
  		("C-c t" . treemacs)))
#+end_src

I want to use this with projectile, which requires the treemacs-projectile package:
#+begin_src emacs-lisp
  (use-package treemacs-projectile
  	:after (treemacs projectile)
  	:ensure t)
#+end_src

* Writing
** Minor Mode
I want to have a minor mode for writing text in emacs. This minor mode should override much of my customization; I want to use a variable-pitch font, enable Olivetti, and change the color theme to have black text on a white background.
#+begin_src emacs-lisp
  (define-minor-mode writing-mode
  	"Minor mode for writing text in a distraction-free environment."
  	:lighter "Writing"
  	:init-value nil
  	(if writing-mode
  		(progn
  			(if (member "Domine" (font-family-list))
  				(setq-local writing--family "Domine")
  				(setq-local writing--family "Times New Roman"))
  			(setq-local face-remapping-alist
  				`((default
  					  :background "#ffffff"
  					  :foreground "#000000"
  					  :family ,writing--family
  					  :height 140)))
  			;; (setq-local face-remapping-alist
  			;; 	(append face-remapping-alist
  			;; 		 '((mode-line (:height 1))
  			;; 		 (mode-line-inactive (:height 1)))))
  			(olivetti-mode 1)
  			(line-number-mode -1)
  			(setq-local writing--mode-line-format mode-line-format)
  			(setq-local mode-line-format nil)
  			(when (bound-and-true-p centaur-tabs-mode)
  				(centaur-tabs-local-mode)
  				(message "toggled")))
  		(buffer-face-mode -1)
  		(kill-local-variable 'face-remapping-alist)
  		(olivetti-mode -1)
  		(setq-local mode-line-format writing--mode-line-format)))
#+end_src

* Miscellaneous
** Exec Path from Shell
This one has come highly recommended; env variables should be grabbed from the shell.
#+begin_src emacs-lisp
  (use-package exec-path-from-shell
      :config
      (exec-path-from-shell-initialize))
#+end_src
** Splash Screen
This is my custom splash screen. Iâ€™ll begin by defining a function for convenience. This inserts some text, centers it in the buffer, and then adds a newline.
#+begin_src emacs-lisp
  (defun center-and-newline (text)
        "Insert the provided TEXT, center and newline."
        (insert text)
        (center-line)
        (insert "\n"))
#+end_src

Next, Iâ€™ll have a function for turning a given buffer into the splash screen:
#+begin_src emacs-lisp
  (defun bendomine/create-splash-screen()
  	(read-only-mode -1)
  	(erase-buffer)

  	(set-fill-column (window-body-width nil))

  	(let* (
                (height (- (window-body-height nil) 1))
                (offset 20)
                (vertical-padding (- (/ height 2) offset)))
  		(insert-char ?\n vertical-padding))

  	(center-and-newline "+---------------------------------------------------------+")
  	(center-and-newline "| 8888888888888b     d888       d8888 .d8888b.  .d8888b.  |")
  	(center-and-newline "| 888       8888b   d8888      d88888d88P  Y88bd88P  Y88b |")
  	(center-and-newline "| 888       88888b.d88888     d88P888888    888Y88b.      |")
  	(center-and-newline "| 8888888   888Y88888P888    d88P 888888        \"Y888b.   |")
  	(center-and-newline "| 888       888 Y888P 888   d88P  888888           \"Y88b. |")
  	(center-and-newline "| 888       888  Y8P  888  d88P   888888    888      \"888 |")
  	(center-and-newline "| 888       888   \"   888 d8888888888Y88b  d88PY88b  d88P |")
  	(center-and-newline "| 8888888888888       888d88P     888 \"Y8888P\"  \"Y8888P\"  |")
  	(center-and-newline "+---------------------------------------------------------+")

  	(insert "\n")

  	(center-and-newline "Customized by Ben Domine")
  	(insert "\n\n")

  	(insert-text-button "Open config file" 'action (lambda (_) (config)) 'follow-link t)
  	(center-line) (insert "\n\n")

  	(insert-text-button "Create org document" 'action (lambda (_)
                                                            (let ((buffer (generate-new-buffer "New org document")))
                                                                (switch-to-buffer buffer)
                                                                (org-mode))) 'follow-link t)
  	(center-line) (insert "\n\n")
  	(insert-text-button "New journal entry" 'action (lambda (_) (org-roam-dailies-capture-today nil "j")) 'follow-link t)
  	
  	(center-line) (insert "\n")

  	(setq mode-line-format nil)
  	(setq cursor-type nil)
  	(setq horizontal-scroll-bar nil)
  	(setq vertical-scroll-bar nil)

  	(read-only-mode 1)
  	(buffer-disable-undo))
#+end_src

Now I have a function to create a buffer and run the previous command:
#+begin_src emacs-lisp
  (defun bendomine/splash-screen ()
      "Display my custom splash screen."
      (interactive)

      (let ((new-buffer (get-buffer-create "*Splash Screen*")))
          (with-current-buffer new-buffer
              (bendomine/create-splash-screen))

          (switch-to-buffer new-buffer)
          (if (or centaur-tabs-mode centaur-tabs-local-mode) (centaur-tabs-local-mode))
          (message "")))
#+end_src

Finally, Iâ€™ll display that splash screen after load, with a tiny delay to ensure that the frame resizes first:
#+begin_src emacs-lisp
  (add-hook 'window-setup-hook (lambda ()
                                   (run-at-time "0.3 sec" nil #'bendomine/splash-screen)))
#+end_src
** Preventing Messages on C-scroll
This is kind of stupid, but I sometimes have the C modifier key held down when scrolling, and I donâ€™t want that to be special behavior:
#+begin_src emacs-lisp
  (global-set-key (kbd "C-<wheel-up>") nil)
  (global-set-key (kbd "C-<wheel-down>") nil)
#+end_src
